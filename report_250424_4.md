## Problem

Link : https://leetcode.com/problems/median-of-two-sorted-arrays/description/

Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.

The overall run time complexity should be O(log (m+n)).

 

Example 1:

Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
Example 2:

Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
 

Constraints:

nums1.length == m
nums2.length == n
0 <= m <= 1000
0 <= n <= 1000
1 <= m + n <= 2000
-106 <= nums1[i], nums2[i] <= 106

## Approach 1
## Pseudo code
```
Ý tưởng : dùng kĩ thuật 2 con trỏ để trộn 2 vector vào 1 vector theo thứ tự tăng dần sau đó xét tổng số phần tử của vector là chẳn hay lẻ => chẵn : phần tử trung vị sẽ có 2 phần tử là (n / 2 - 1) và n / 2 và tính trung bình ra ; lẻ thì phần tử trung vị là n / 2

vector<int> res
i = 0, j = 0
while i < size(nums1) && j < size(nums2)
    if nums1[i] <= nums2[j]
        push_back(nums1[i]) in res
        i++
    else
        push_back(nums2[j]) in res
        j++
while i < size(nums1)
    push_back(nums1[i]) in res
    i++
while j < size(nums2)
    push_back(nums2[j]) in res
    j++;
n = size(res)
if n % 2 == 0  return 1.0 * (res[n / 2 - 1] + res[n / 2]) / 2
else return res[n / 2]

```
## Code
```
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        vector<int> res;
        int i = 0, j = 0;
        while(i < nums1.size() && j < nums2.size()){
            if(nums1[i] <= nums2[j]){
                res.push_back(nums1[i]);
                i++;
            }
            else{
                res.push_back(nums2[j]);
                j++;
            }
        }
        while(i < nums1.size()){
            res.push_back(nums1[i]);
            i++;
        }
        while(j < nums2.size()){
            res.push_back(nums2[j]);
            j++;
        }

        int n = res.size();
        if(n % 2 == 0) return 1.0 * (res[n / 2 - 1] + res[n / 2]) / 2;
        else return res[n / 2];
    }
};
```

## Approach 2
### Pseudo
```
ý tưởng: dùng mảng phân đoạn, segment array. Giả sử hai mảng đã được sắp xếp và trộn lẫn vào nhau, mục đích là ta đi tìm vị trí chính giữa của mảng trộn ấy
trong hai mảng, thực tế là ta không có trộn lẫn hai mảng)
- nếu tổng số lượng phần tử là m + n = s thì nếu s lẻ thì ta chỉ cần tìm vị trị s/2, nhưng nếu s chẳn thì ta cần tìm hai vị trí s1 = s/2 - 1 và s2 = s/2

function solve (a: array, b: array,k,  fa, la, fb, lb) -> int:
    if la < fa then return b[k-fa]
    if lb < fb then return a[k-fb]

    ma = (la + fa)/2
    mb = (lb + fb)/2

    va = a[ma]
    vb = b[mb]

    if ma + mb < k then:
       if va > vb then retrun solve (a, b, k, fa, la, mb + 1, lb)
       else return solve (a, b, k, ma + 1, la, fb, lb)
    else then
       if va > vb then return solve (a, b, k, fa, ma - 1, fa, lb)
       else return solve (a, b, k, fa, la, fb, mb - 1)
    return -1
end.

function FMSA (a, b: array ) -> double:
    n = size of a
    m = size of b
    s = m  + n
     if s is odd then return solve (a,b,s/2, 0, n - 1, 0, m-1)
     else return solve (solve (a, b, s/2 -1, 0, n-1, 0, m-1) + solve (a,b, s/2, 0, n-1, 0, m-1))/2
end.

```
### Code
```
class Solution {
public:
    // segment array
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int n = (int)nums1.size ();
        int m = (int)nums2.size ();
        int sz = n + m;
        if (!(sz&1)) {
            return (1.0*FTV (nums1, nums2, sz/2 -1, 0, n-1, 0, m-1) + 1.0*FTV (nums1, nums2, sz/2, 0, n-1, 0, m-1))/2;
        }else return FTV (nums1, nums2, sz/2, 0, n-1, 0, m-1);
    }
    int FTV (vector <int>& v1, vector <int>& v2, int targetID, int fa, int la, int fb, int lb) {
        // the endpoint, if the target does not exit int either v1 or v2 then return the correspond in the other array
        if (la < fa) return v2[targetID - fa];
        if (lb < fb) return v1[targetID - fb];

        int v1midID = (fa + la) /2;
        int v1midVal = v1[v1midID];
        int v2midID = (fb + lb) /2;
        int v2midVal = v2[v2midID];

        if (v1midID + v2midID < targetID){
            if (v1midVal > v2midVal) return FTV (v1, v2, targetID, fa, la, v2midID + 1, lb);
            else return FTV (v1, v2, targetID, v1midID + 1, la, fb, lb);
        }
        else {
            if (v1midVal > v2midVal) return FTV (v1, v2, targetID, fa, v1midID -1, fb, lb);
            else return FTV (v1, v2, targetID, fa, la, fb, v2midID - 1);
        }
        return -1;
    }
};
```
