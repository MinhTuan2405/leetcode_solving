## Problem
Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.
 

Example 1:

Input: s = "()"
Output: true
Example 2:

Input: s = "()[]{}"
Output: true
Example 3:

Input: s = "(]"
Output: false
 

Constraints:

1 <= s.length <= 104
s consists of parentheses only '()[]{}'.

## approach 1:
### Pseudo
```
ý tưởng, dùng stack để lưu từng phânf tử mở ngoặc, sau đó so sánh với các phần tử đóng ngoặc và pop ra khỏi stack đến khi nó rỗng thì là chuỗi đúng ngược lại là sai,


stack character st;
if the first char in st is close curly -> return fasle;
else push to stack;
for element in the string s:
    if the open curly -> push to s;
    else if the close curly that is suitable with top of s then pop the top of s

ìf the stack is empty return true;
else return false;
```

### Code

```
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        for(char x : s){
            if(x == '(' || x == '{' || x == '[') st.push(x);
            else if(st.empty()) return false;
            else{
                if((x == ')' && st.top() != '(') || (x == '}' && st.top() != '{') || (x == ']' && st.top() != '[')) return false;
                st.pop();
            }
        }
        return st.empty();
    }
};
```

## approach 2:
### Pseudo
```
Ý tưởng: 
- Tách toàn bộ các kí tự đặc biệt sang một string symbolsContain, dùng regex với pattern là {}, [], ().
- Chạy một vòng while cho tới khi trong chuỗi không còn ngoặc nào là {}, [], () thì dừng lại, mỗi lần lặp thì sẽ replace  {}, [], () bằng chuỗi rỗng để xóa nó đi.
- Khi nào dừng vòng while nếu string rỗng thì hợp lệ, nếu dư kí tự nào thì sẽ là không hợp lệ

symbolsContain = "";
regexp R"(\{\}|\(\)|\[\])" // chỉ xét đoạn nào có (), {}, []
map mp // lưu các kí tự đặc biệt

for i -> s.length():
    if (mp[s[i]]):  // Nếu kí tự tồn tại trong mảng
        symbolsContain += s[i];

if (symbolsContain.length() % 2 == 0) {
    do {
        symbolsContain = regex_replace(symbolsContain, regexp, "")  //replace  {}, [], () bằng chuỗi rỗng để xóa nó đi
        if (regex_search(symbolsContain, regexp)) : break   // Nếu không tìm thấy thì dừng vòng lặp
    } while (true)

    if (symbolsContain.length() == 0) {
        return true     // Nếu không còn giá trị thì nghĩa là đã triệt tiêu hết => hợp lệ
    } else {
        return false    // Không hợp lệ vì còn kí tự bên trong
    }
} else {
    return false    // Nếu là TH số lẻ thì sẽ lỗi vì mỗi cặp đều có dấu đóng mở
}
```

### Code
```
class Solution {
public:
    bool isValid(string s) {
        string symbolsContain;
        regex regexp(R"(\{\}|\(\)|\[\])");

        unordered_map<char, bool> mp;
        mp['{'] = mp['('] = mp['['] = mp['}'] = mp[')'] = mp[']'] = true;

        for (int i = 0; i < s.length(); i++) {
            if (mp[s[i]]) {
                symbolsContain += s[i];
            }
        }
        
        if (symbolsContain.length() % 2 == 0) {

            do {
                symbolsContain = regex_replace(symbolsContain, regexp, "");
                if (!regex_search(symbolsContain, regexp)) {
                    break;
                }
            } while (true);

            if (symbolsContain.empty()) {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }
};
```

